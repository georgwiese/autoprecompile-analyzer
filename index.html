<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>APC Effectiveness Analyzer</title>

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
        body {
            background-color: #f8f9fa;
        }

        .drop-zone {
            border: 3px dashed #dee2e6;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background-color: white;
        }

        .drop-zone:hover,
        .drop-zone.dragover {
            border-color: #0d6efd;
            background-color: #e7f1ff;
        }

        .chart-container {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        .bar-highlight {
            stroke: #ffc10755 !important;
            stroke-width: 2 !important;
        }
        
        .bar-selected {
            stroke: #ffc107 !important;
            stroke-width: 4 !important;
        }

        .code-panel {
            font-family: 'Courier New', monospace;
            background-color: #f8f9fa;
            border-radius: 5px;
            padding: 15px;
            max-height: 500px;
            overflow-y: auto;
        }

        .code-block {
            border: 1px solid #dee2e6;
            border-radius: 3px;
            margin: 10px 0;
            padding: 10px;
            background-color: white;
        }

        .code-block-header {
            font-weight: bold;
            margin-bottom: 5px;
            color: #495057;
            font-size: 12px;
        }

        .code-block.selected {
            border-color: #ffc107;
            background-color: #fff9e6;
            box-shadow: 0 0 5px rgba(255, 193, 7, 0.3);
        }

        .code-line {
            margin: 2px 0;
            padding: 2px 5px;
            cursor: pointer;
        }

        .code-line:hover {
            background-color: #e9ecef;
        }

        .code-line.highlighted {
            background-color: #fff3cd;
        }

        .tooltip {
            position: absolute;
            text-align: left;
            padding: 10px;
            font: 12px sans-serif;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            border-radius: 5px;
            pointer-events: none;
            z-index: 1000;
        }

        .bar {
            stroke: black;
            stroke-width: 0.5;
            opacity: 0.8;
            cursor: pointer;
        }

        .bar:hover {
            opacity: 1;
        }

        .mean-line {
            stroke: red;
            stroke-width: 2;
            stroke-dasharray: 5, 5;
            opacity: 0.7;
        }

        .grid line {
            stroke: #e0e0e0;
            stroke-opacity: 0.7;
        }

        .grid path {
            stroke-width: 0;
        }
    </style>
</head>

<body>
    <nav class="navbar navbar-dark bg-primary">
        <div class="container-fluid">
            <span class="navbar-brand mb-0 h1" id="pageTitle" style="cursor: pointer;">APC Effectiveness Analyzer</span>
        </div>
    </nav>

    <div class="container mt-4">
        <!-- File Upload Section -->
        <div id="uploadSection" class="row mb-4">
            <div class="col-12">
                <div class="drop-zone" id="dropZone">
                    <h4>Drop JSON file here or click to upload</h4>
                    <p class="text-muted">Upload APC candidates JSON file</p>
                    <input type="file" id="fileInput" accept=".json" style="display: none;">
                </div>
                <div class="mt-3">
                    <div class="input-group">
                        <span class="input-group-text">Or paste URL:</span>
                        <input type="text" id="urlInput" class="form-control" placeholder="https://example.com/data.json or GitHub link">
                        <button class="btn btn-primary" id="loadUrlBtn">Load from URL</button>
                    </div>
                    <small class="text-muted">Supports direct JSON URLs and GitHub file links</small>
                </div>
            </div>
        </div>

        <!-- Controls Section (hidden initially) -->
        <div id="controlsSection" class="row mb-4" style="display: none;">
            <div class="col-12">
                <div class="row align-items-end">
                    <div class="col-md-3">
                        <label for="effectivenessType" class="form-label">Effectiveness Metric:</label>
                        <select id="effectivenessType" class="form-select">
                            <option value="cost" selected>Cost</option>
                            <option value="main_columns">Main Columns</option>
                            <option value="constraints">Constraints</option>
                            <option value="bus_interactions">Bus Interactions</option>
                        </select>
                    </div>
                    <div class="col-md-3 ms-auto">
                        <label for="pcSearch" class="form-label">Block ID:</label>
                        <div class="input-group">
                            <input type="text" id="pcSearch" class="form-control">
                            <button class="btn btn-primary" id="pcSearchBtn">Go</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Visualization Section (hidden initially) -->
        <div id="vizSection" style="display: none;">
            <div class="row">
                <div class="col-12">
                    <div class="chart-container">
                        <div id="chart"></div>
                    </div>
                </div>
            </div>

            <!-- Code Panel Section -->
            <div class="row mt-4">
                <div class="col-12">
                    <div class="chart-container">
                        <h5>Program Code</h5>
                        <div class="mb-2">
                            <span id="codeBlockInfo" class="text-muted">Click on a bar or code line to select a block</span>
                        </div>
                        <div id="codePanel" class="code-panel">
                            <span class="text-muted">No data loaded</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentData = null;
        let chart = null;
        let selectedBlock = null;

        // File handling
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const uploadSection = document.getElementById('uploadSection');
        const controlsSection = document.getElementById('controlsSection');
        const vizSection = document.getElementById('vizSection');
        const effectivenessType = document.getElementById('effectivenessType');
        const pageTitle = document.getElementById('pageTitle');
        const pcSearch = document.getElementById('pcSearch');
        const pcSearchBtn = document.getElementById('pcSearchBtn');

        // Drop zone events
        dropZone.addEventListener('click', () => fileInput.click());

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        // URL loading functionality
        const urlInput = document.getElementById('urlInput');
        const loadUrlBtn = document.getElementById('loadUrlBtn');

        loadUrlBtn.addEventListener('click', loadFromUrl);
        urlInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                loadFromUrl();
            }
        });

        async function loadFromUrl() {
            const url = urlInput.value.trim();
            if (!url) {
                alert('Please enter a URL');
                return;
            }

            // Convert GitHub URLs to raw URLs
            let fetchUrl = url;
            if (url.includes('github.com') && !url.includes('raw.githubusercontent.com')) {
                // Convert github.com/user/repo/blob/branch/file to raw.githubusercontent.com/user/repo/branch/file
                fetchUrl = url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
            }

            try {
                loadUrlBtn.disabled = true;
                loadUrlBtn.textContent = 'Loading...';
                
                const response = await fetch(fetchUrl);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const text = await response.text();
                try {
                    currentData = JSON.parse(text);
                    uploadSection.style.display = 'none';
                    controlsSection.style.display = 'block';
                    vizSection.style.display = 'block';
                    updateVisualization();
                    
                    // Update URL to include the data parameter
                    const newUrl = new URL(window.location);
                    newUrl.searchParams.set('data', url);
                    window.history.replaceState({}, document.title, newUrl);
                } catch (parseError) {
                    alert('Error parsing JSON from URL: ' + parseError.message);
                }
            } catch (error) {
                alert('Error loading URL: ' + error.message);
            } finally {
                loadUrlBtn.disabled = false;
                loadUrlBtn.textContent = 'Load from URL';
            }
        }

        effectivenessType.addEventListener('change', () => {
            if (currentData) {
                const selectedPc = selectedBlock ? selectedBlock.start_pc : null;
                updateVisualization();

                // Restore selection if it exists
                if (selectedPc) {
                    const data = processData();
                    const block = data.find(d => d.start_pc === selectedPc);
                    if (block) {
                        selectBlock(block);
                    }
                }
            }
        });

        // PC search functionality
        pcSearchBtn.addEventListener('click', searchForPC);
        pcSearch.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                searchForPC();
            }
        });

        function searchForPC() {
            if (!currentData) {
                alert('Please load data first');
                return;
            }

            const input = pcSearch.value.trim();
            if (!input) {
                // Empty input means unselect
                selectBlock(null);
                return;
            }

            // Parse hex (0x...) or decimal
            let pcValue;
            if (input.toLowerCase().startsWith('0x')) {
                pcValue = parseInt(input, 16);
            } else {
                pcValue = parseInt(input, 10);
            }

            if (isNaN(pcValue)) {
                alert('Invalid PC address. Please enter a valid hex (0x...) or decimal number.');
                return;
            }

            // Find the block that contains this PC
            // Each instruction is 4 bytes, so PC advances by 4
            const data = processData();
            const block = data.find(d => {
                if (d.is_other) return false; // Skip "Other" grouped blocks
                const startPc = d.start_pc;
                const endPc = startPc + (d.instructions * 4);
                return pcValue >= startPc && pcValue < endPc;
            });

            if (block) {
                selectBlock(block);
            } else {
                alert(`No block found containing PC: 0x${pcValue.toString(16)} (${pcValue})`);
            }
        }
        
        pageTitle.addEventListener('click', () => {
            currentData = null;
            selectedBlock = null;
            uploadSection.style.display = 'block';
            controlsSection.style.display = 'none';
            vizSection.style.display = 'none';
            fileInput.value = '';
            urlInput.value = '';
            // Clear URL parameters when returning to upload screen
            window.history.replaceState({}, document.title, window.location.pathname);
        });

        // Check for URL parameter on page load
        window.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const dataUrl = urlParams.get('url') || urlParams.get('data');
            
            if (dataUrl) {
                urlInput.value = dataUrl;
                loadFromUrl();
            }
        });

        function handleFile(file) {
            if (!file.name.endsWith('.json')) {
                alert('Please upload a JSON file');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    currentData = JSON.parse(e.target.result);
                    uploadSection.style.display = 'none';
                    controlsSection.style.display = 'block';
                    vizSection.style.display = 'block';
                    updateVisualization();
                } catch (error) {
                    alert('Error parsing JSON file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        function calculateEffectiveness(item, effType) {
            switch (effType) {
                case 'cost':
                    return item.cost_before / item.cost_after;
                case 'main_columns':
                    return item.stats.before.main_columns / item.stats.after.main_columns;
                case 'constraints':
                    return item.stats.before.constraints / item.stats.after.constraints;
                case 'bus_interactions':
                    return item.stats.before.bus_interactions / item.stats.after.bus_interactions;
                default:
                    throw new Error(`Unknown effectiveness type: ${effType}`);
            }
        }

        function formatCellCount(count) {
            if (count >= 1e9) {
                return (count / 1e9).toFixed(1) + 'B';
            } else if (count >= 1e6) {
                return (count / 1e6).toFixed(1) + 'M';
            } else if (count >= 1e3) {
                return (count / 1e3).toFixed(1) + 'K';
            } else {
                return count.toFixed(0);
            }
        }

        function processData() {
            const effType = effectivenessType.value;
            const processed = currentData.map(item => ({
                start_pc: item.original_block.start_pc,
                effectiveness: calculateEffectiveness(item, effType),
                instructions: item.original_block.statements.length,
                software_version_cells: item.width_before * item.execution_frequency,
                width_before: item.width_before,
                execution_frequency: item.execution_frequency,
                statements: item.original_block.statements,  // Keep the code statements
                stats_after: item.stats.after  // Keep APC stats
            }));

            // Sort by software_version_cells descending
            processed.sort((a, b) => b.software_version_cells - a.software_version_cells);

            return processed;
        }

        function updateVisualization() {
            const data = processData();
            const totalCells = data.reduce((sum, d) => sum + d.software_version_cells, 0);

            // Calculate weighted mean
            const meanEffectiveness = data.reduce((sum, d) => sum + d.effectiveness * d.software_version_cells, 0) / totalCells;

            // Create visualization
            createChart(data, totalCells, meanEffectiveness);

            // Show all code in the code panel
            showAllCode();

            // Check for block parameter in URL and select it
            const urlParams = new URLSearchParams(window.location.search);
            const blockParam = urlParams.get('block');
            if (blockParam) {
                const blockPc = parseInt(blockParam, 16);
                const block = data.find(d => d.start_pc === blockPc);
                if (block) {
                    selectBlock(block);
                }
            }
        }

        function highlightElements(startPc, isHover = true) {
            // Highlight corresponding bar
            d3.selectAll('.bar')
                .classed('bar-highlight', d => d.start_pc === startPc);
        }

        function clearHighlights() {
            d3.selectAll('.bar').classed('bar-highlight', false);
        }
        
        function selectBlock(blockData) {
            // Clear previous selection
            d3.selectAll('.bar').classed('bar-selected', false);

            // Set new selection
            selectedBlock = blockData;

            // Update URL
            const newUrl = new URL(window.location);
            if (blockData && !blockData.is_other) {
                // Highlight selected bar
                d3.selectAll('.bar')
                    .classed('bar-selected', d => d.start_pc === blockData.start_pc);

                // Update URL with block parameter
                newUrl.searchParams.set('block', '0x' + blockData.start_pc.toString(16));

                // Update the PC search input field
                pcSearch.value = '0x' + blockData.start_pc.toString(16);
            } else {
                // Clear block parameter if deselecting or selecting "Other"
                newUrl.searchParams.delete('block');

                // Clear the PC search input field
                pcSearch.value = '';
            }
            window.history.replaceState({}, document.title, newUrl);

            // Update code panel selection
            updateCodePanelSelection(blockData);
        }

        function showAllCode() {
            const codePanel = document.getElementById('codePanel');

            // Get all blocks sorted by start_pc
            const allBlocks = processData().sort((a, b) => a.start_pc - b.start_pc);

            let codeHtml = '';
            allBlocks.forEach((block, index) => {
                if (block.is_other) return; // Skip "Other" grouped blocks

                // Check for gap between previous block and current block
                if (index > 0) {
                    const prevBlock = allBlocks[index - 1];
                    if (!prevBlock.is_other) {
                        const prevBlockEnd = prevBlock.start_pc + (prevBlock.instructions * 4);
                        const gap = block.start_pc - prevBlockEnd;
                        const missingInstructions = gap / 4;

                        if (missingInstructions > 0) {
                            codeHtml += `
                                <div style="padding: 10px; margin: 10px 0; background-color: #f0f0f0; border-left: 3px solid #999; font-style: italic; color: #666;">
                                    ... ${missingInstructions} instruction${missingInstructions !== 1 ? 's' : ''} not shown (0x${prevBlockEnd.toString(16)} - 0x${(block.start_pc - 4).toString(16)}) ...
                                </div>
                            `;
                        }
                    }
                }

                const blockId = `block-${block.start_pc}`;
                const headerText = `PC: 0x${block.start_pc.toString(16)} | Cells: ${formatCellCount(block.software_version_cells)} | Effectiveness: ${block.effectiveness.toFixed(2)} | Instructions: ${block.instructions}`;

                const linesHtml = block.statements.map((stmt, idx) =>
                    `<div class="code-line" data-pc="${block.start_pc}" data-line="${idx}">${escapeHtml(stmt)}</div>`
                ).join('');

                codeHtml += `
                    <div class="code-block" id="${blockId}" data-pc="${block.start_pc}">
                        <div class="code-block-header">${headerText}</div>
                        ${linesHtml}
                    </div>
                `;
            });

            codePanel.innerHTML = codeHtml;

            // Add click handlers to code lines
            document.querySelectorAll('.code-line').forEach(line => {
                line.addEventListener('click', function() {
                    const pc = parseInt(this.getAttribute('data-pc'));
                    const blockData = allBlocks.find(b => b.start_pc === pc);
                    if (blockData) {
                        selectBlock(blockData);
                    }
                });
            });
        }

        function updateCodePanelSelection(blockData) {
            const codeInfo = document.getElementById('codeBlockInfo');

            // Remove all previous selections
            document.querySelectorAll('.code-block').forEach(block => {
                block.classList.remove('selected');
            });
            document.querySelectorAll('.code-line').forEach(line => {
                line.classList.remove('highlighted');
            });

            if (!blockData) {
                codeInfo.innerHTML = '<span class="text-muted">Click on a bar or code line to select a block</span>';
                return;
            }

            if (blockData.is_other) {
                codeInfo.innerHTML = `
                    <strong>Other blocks (${blockData.count} APCs grouped)</strong><br/>
                    <span>Cells (software version): ${formatCellCount(blockData.software_version_cells)}</span> •
                    <span>Execution frequency: ${formatCellCount(blockData.execution_frequency)}</span><br/>
                    <span>Effectiveness: ${blockData.effectiveness.toFixed(2)}</span><br/>
                    <span>APC size (total): ${blockData.stats_after.main_columns || 0} columns, ${blockData.stats_after.bus_interactions || 0} bus interactions, ${blockData.stats_after.constraints || 0} constraints</span>
                `;
                return;
            }

            codeInfo.innerHTML = `
                <strong>Block at PC: 0x${blockData.start_pc.toString(16)}</strong><br/>
                <span>Cells (software version): ${formatCellCount(blockData.software_version_cells)}</span> •
                <span>Execution frequency: ${formatCellCount(blockData.execution_frequency)}</span> •
                <span>Instructions: ${blockData.instructions}</span><br/>
                <span>Effectiveness: ${blockData.effectiveness.toFixed(2)}</span><br/>
                <span>APC size: ${blockData.stats_after.main_columns} columns, ${blockData.stats_after.bus_interactions} bus interactions, ${blockData.stats_after.constraints} constraints</span>
            `;

            // Highlight the selected block
            const blockElement = document.getElementById(`block-${blockData.start_pc}`);
            if (blockElement) {
                blockElement.classList.add('selected');

                // Highlight all lines in this block
                blockElement.querySelectorAll('.code-line').forEach(line => {
                    line.classList.add('highlighted');
                });

                // Scroll within the code panel only
                const codePanel = document.getElementById('codePanel');
                const blockTop = blockElement.offsetTop - codePanel.offsetTop;
                codePanel.scrollTo({ top: blockTop, behavior: 'smooth' });
            }
        }

        function clearCode() {
            // Only clear if there's no selected block
            if (!selectedBlock) {
                document.getElementById('codeBlockInfo').innerHTML = '<span class="text-muted">Click on a bar or code line to select a block</span>';
                showAllCode();
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function createChart(data, totalCells, meanEffectiveness) {
            // Clear existing chart
            d3.select('#chart').selectAll('*').remove();

            // Set dimensions and margins
            const margin = { top: 40, right: 120, bottom: 60, left: 80 };
            const width = 1200 - margin.left - margin.right;
            const height = 225 - margin.top - margin.bottom;

            // Group small blocks (< 0.1% threshold)
            const threshold = totalCells * 0.001;
            const largeBlocks = data.filter(d => d.software_version_cells >= threshold);
            const smallBlocks = data.filter(d => d.software_version_cells < threshold);

            let plotData = [...largeBlocks];

            if (smallBlocks.length > 0) {
                const otherCells = smallBlocks.reduce((sum, d) => sum + d.software_version_cells, 0);
                const otherEffectiveness = smallBlocks.reduce((sum, d) => sum + d.effectiveness * d.software_version_cells, 0) / otherCells;
                const otherExecFreq = smallBlocks.reduce((sum, d) => sum + d.execution_frequency, 0);
                const otherStatsAfter = smallBlocks.reduce((acc, d) => {
                    if (d.stats_after) {
                        acc.main_columns = (acc.main_columns || 0) + d.stats_after.main_columns;
                        acc.bus_interactions = (acc.bus_interactions || 0) + d.stats_after.bus_interactions;
                        acc.constraints = (acc.constraints || 0) + d.stats_after.constraints;
                    }
                    return acc;
                }, {});
                plotData.push({
                    effectiveness: otherEffectiveness,
                    software_version_cells: otherCells,
                    execution_frequency: otherExecFreq,
                    instructions: -1,
                    is_other: true,
                    count: smallBlocks.length,
                    statements: [],  // No individual statements for grouped blocks
                    stats_after: otherStatsAfter
                });
            }

            // Calculate positions
            let xPos = 0;
            plotData.forEach(d => {
                d.x = xPos;
                d.width = d.software_version_cells;
                xPos += d.width;
            });

            // Create SVG
            const svg = d3.select('#chart')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .on('click', function(event) {
                    // If clicking on the background (not a bar), deselect
                    if (event.target.tagName === 'svg') {
                        selectBlock(null);
                    }
                })
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Add background rect to capture clicks
            svg.append('rect')
                .attr('width', width)
                .attr('height', height)
                .style('fill', 'none')
                .style('pointer-events', 'all')
                .on('click', function(event) {
                    event.stopPropagation();
                    selectBlock(null);
                });

            // Create scales
            const xScale = d3.scaleLinear()
                .domain([0, totalCells])
                .range([0, width]);

            // Calculate 99th percentile effectiveness by trace cells
            // Sort by effectiveness ascending
            const sortedByEffectiveness = [...plotData].sort((a, b) => a.effectiveness - b.effectiveness);

            // Find the effectiveness value at 99th percentile weighted by trace cells
            let cumulativeCells = 0;
            const p99Threshold = totalCells * 0.99;
            let maxEffectivenessP99 = 0;

            for (const d of sortedByEffectiveness) {
                cumulativeCells += d.software_version_cells;
                maxEffectivenessP99 = d.effectiveness;
                if (cumulativeCells >= p99Threshold) {
                    break;
                }
            }

            // Use 99th percentile for y-axis scaling
            const yScale = d3.scaleLinear()
                .domain([0, maxEffectivenessP99 * 1.1])
                .range([height, 0]);

            // Color scale for instructions (log scale)
            const validInstructions = plotData.filter(d => !d.is_other).map(d => d.instructions);
            const colorScale = d3.scaleSequentialLog()
                .domain([d3.min(validInstructions), d3.max(validInstructions)])
                .interpolator(d3.interpolateRdYlGn);

            // Add grid
            svg.append('g')
                .attr('class', 'grid')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale)
                    .tickSize(-height)
                    .tickFormat(''));

            svg.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(yScale)
                    .tickSize(-width)
                    .tickFormat(''));

            // Create tooltip
            const tooltip = d3.select('body').append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);

            // Add bars
            svg.selectAll('.bar')
                .data(plotData)
                .enter().append('rect')
                .attr('class', 'bar')
                .attr('x', d => xScale(d.x))
                .attr('y', d => Math.max(0, yScale(d.effectiveness)))
                .attr('width', d => xScale(d.width) - xScale(0))
                .attr('height', d => height - Math.max(0, yScale(d.effectiveness)))
                .style('fill', d => d.is_other ? 'lightgray' : colorScale(d.instructions))
                .on('mouseover', function (event, d) {
                    // Show tooltip
                    tooltip.transition()
                        .duration(200)
                        .style('opacity', .9);

                    let content = '';
                    if (d.is_other) {
                        content = `<strong>Other (${d.count} APCs)</strong><br/>
                                  Cells (software version): ${formatCellCount(d.software_version_cells)}<br/>
                                  Execution frequency: ${formatCellCount(d.execution_frequency)}<br/>
                                  Effectiveness: ${d.effectiveness.toFixed(2)}<br/>
                                  APC columns (total): ${d.stats_after.main_columns || 'N/A'}<br/>
                                  APC bus interactions (total): ${d.stats_after.bus_interactions || 'N/A'}<br/>
                                  APC constraints (total): ${d.stats_after.constraints || 'N/A'}`;
                    } else {
                        content = `<strong>PC: 0x${d.start_pc.toString(16)}</strong><br/>
                                  Cells (software version): ${formatCellCount(d.software_version_cells)}<br/>
                                  Execution frequency: ${formatCellCount(d.execution_frequency)}<br/>
                                  Effectiveness: ${d.effectiveness.toFixed(2)}<br/>
                                  Instructions: ${d.instructions}<br/>
                                  APC columns: ${d.stats_after.main_columns}<br/>
                                  APC bus interactions: ${d.stats_after.bus_interactions}<br/>
                                  APC constraints: ${d.stats_after.constraints}`;
                    }

                    tooltip.html(content)
                        .style('left', (event.pageX - 50) + 'px')
                        .style('top', (event.pageY + 20) + 'px');

                    // Highlight elements (but don't change code on hover if something is selected)
                    if (!d.is_other) {
                        highlightElements(d.start_pc, true);
                    }
                })
                .on('mouseout', function (d) {
                    // Hide tooltip
                    tooltip.transition()
                        .duration(500)
                        .style('opacity', 0);

                    // Clear highlights
                    clearHighlights();
                })
                .on('click', function(event, d) {
                    event.stopPropagation();
                    // Select this block on click
                    selectBlock(d);
                });
            
            // Note: Selection is handled in the selectBlock function after chart is created

            // Add "Other" label for wide enough other blocks
            plotData.filter(d => d.is_other && d.width > totalCells * 0.02).forEach(d => {
                svg.append('text')
                    .attr('x', xScale(d.x + d.width / 2))
                    .attr('y', yScale(d.effectiveness / 2))
                    .attr('text-anchor', 'middle')
                    .attr('font-size', '10px')
                    .attr('font-weight', 'bold')
                    .text(`Other (${d.count} APCs)`);
            });

            // Add mean line
            svg.append('line')
                .attr('class', 'mean-line')
                .attr('x1', 0)
                .attr('x2', width)
                .attr('y1', yScale(meanEffectiveness))
                .attr('y2', yScale(meanEffectiveness));

            // Add axes
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale)
                    .tickFormat(d => formatCellCount(d)));

            svg.append('g')
                .call(d3.axisLeft(yScale));

            // Add labels
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .text('Effectiveness');

            svg.append('text')
                .attr('transform', `translate(${width / 2}, ${height + margin.bottom})`)
                .style('text-anchor', 'middle')
                .text('Cumulative instruction trace cells (software version)');

            // Add title
            const effType = effectivenessType.options[effectivenessType.selectedIndex].text;
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', 0 - margin.top / 2)
                .attr('text-anchor', 'middle')
                .style('font-size', '16px')
                .style('font-weight', 'bold')
                .text(`Effectiveness by Basic Block (reduction in ${effType})`);

            // Add mean text box
            svg.append('rect')
                .attr('x', 5)
                .attr('y', 5)
                .attr('width', 80)
                .attr('height', 25)
                .style('fill', 'wheat')
                .style('opacity', 0.8)
                .style('stroke', 'gray')
                .style('stroke-width', 1)
                .style('rx', 3);

            svg.append('text')
                .attr('x', 45)
                .attr('y', 22)
                .attr('text-anchor', 'middle')
                .style('font-size', '12px')
                .text(`Mean: ${meanEffectiveness.toFixed(2)}`);

            // Add color legend
            if (validInstructions.length > 0) {
                const legendWidth = 20;
                const legendHeight = 200;

                const legendScale = d3.scaleLinear()
                    .domain([Math.log10(d3.min(validInstructions)), Math.log10(d3.max(validInstructions))])
                    .range([legendHeight, 0]);

                const legendAxis = d3.axisRight(legendScale)
                    .ticks(5)
                    .tickFormat(d => Math.pow(10, d).toFixed(0));

                const legend = svg.append('g')
                    .attr('transform', `translate(${width + 40}, ${height / 2 - legendHeight / 2})`);

                // Create gradient
                const gradientId = 'instruction-gradient';
                const gradient = svg.append('defs')
                    .append('linearGradient')
                    .attr('id', gradientId)
                    .attr('x1', '0%')
                    .attr('y1', '100%')
                    .attr('x2', '0%')
                    .attr('y2', '0%');

                const steps = 20;
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const value = d3.min(validInstructions) * Math.pow(d3.max(validInstructions) / d3.min(validInstructions), t);
                    gradient.append('stop')
                        .attr('offset', `${t * 100}%`)
                        .style('stop-color', colorScale(value));
                }

                legend.append('rect')
                    .attr('width', legendWidth)
                    .attr('height', legendHeight)
                    .style('fill', `url(#${gradientId})`);

                legend.append('g')
                    .attr('transform', `translate(${legendWidth}, 0)`)
                    .call(legendAxis);

                legend.append('text')
                    .attr('transform', `rotate(90)`)
                    .attr('y', -legendWidth - 30)
                    .attr('x', legendHeight / 2)
                    .style('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .text('Instructions (log)');
            }
        }
    </script>
</body>

</html>