# APC Effectiveness Analyzer - Project Documentation

## Overview
This is a web-based visualization tool for analyzing the effectiveness of Automatic Precompile (APC) candidates in zkVM (Zero-Knowledge Virtual Machine) environments. The tool helps evaluate the performance impact of generating specialized precompiles for each basic block in a RISC-V program.

### Context
In zkVM systems, precompiles can significantly reduce the computational cost of proving program execution. This analyzer visualizes how effective each automatically generated precompile is at reducing various computational metrics. The tool is a web-based port of the original Python script `plot_effectiveness.py` from the powdr project.

## Project Structure
```
autoprecomile-analyzer/
├── index.html          # Single-page application with embedded JS/CSS
└── Claude.md          # This documentation file
```

## Key Features

### 1. Data Input Methods
- **File Upload**: Drag-and-drop or click to upload JSON files
- **URL Loading**: Direct JSON URLs or GitHub file links support
- **Format**: Expects JSON array of APC candidate objects

### 2. Effectiveness Metrics
The tool calculates effectiveness as a ratio (before/after) for zkVM-specific metrics:
- **Cost**: Overall computational cost reduction in the zkVM prover
- **Main Columns**: Reduction in main column usage (polynomial commitments in the proof system)
- **Constraints**: Reduction in constraint count (arithmetic constraints that must be satisfied)
- **Bus Interactions**: Reduction in bus interaction overhead (communication between different parts of the zkVM)

### 3. Interactive Visualizations

#### Bar Chart
- X-axis: Cumulative instruction trace cells (software version)
- Y-axis: Effectiveness ratio
- Color coding: Log scale based on instruction count (green=few, red=many)
- Small blocks (<0.1% of total cells) grouped as "Other"
- Red dashed line shows weighted mean effectiveness

#### Statistics Table
- Shows top 10 basic blocks by trace cell count
- Columns: Start PC, Trace Cells, Effectiveness, Instructions
- Click/hover interactions synchronized with bar chart

#### Code Panel
- Displays actual code statements for selected basic blocks
- Shows PC address and instruction count
- Updates on bar/table selection

### 4. User Interactions
- **Hover**: Highlights corresponding elements across all views
- **Click**: Selects a block and displays its code
- **Title Click**: Returns to upload screen
- **Metric Switch**: Dynamically recalculates all visualizations

## Data Format

Expected JSON structure (generated by the APC tool analyzing RISC-V programs):
```json
[
  {
    "original_block": {
      "start_pc": 12345,              // Program counter address in RISC-V program
      "statements": ["instruction1", "instruction2", ...]  // RISC-V assembly instructions
    },
    "cost_before": 1000,               // zkVM proving cost without precompile
    "cost_after": 500,                 // zkVM proving cost with precompile
    "width_before": 100,               // Number of trace rows without precompile
    "execution_frequency": 50000,      // How often this block is executed
    "stats": {
      "before": {                      // Metrics without precompile
        "main_columns": 100,
        "constraints": 200,
        "bus_interactions": 50
      },
      "after": {                       // Metrics with precompile
        "main_columns": 50,
        "constraints": 100,
        "bus_interactions": 25
      }
    }
  }
]
```

## Technical Implementation

### Libraries Used
- **Bootstrap 5.3.0**: UI framework for responsive design
- **D3.js v7**: Data visualization and chart rendering

### Key Functions

#### Data Processing
- `calculateEffectiveness()`: Computes effectiveness ratios based on selected metric
- `processData()`: Transforms raw data for visualization
- `formatCellCount()`: Human-readable formatting (K/M/B suffixes)

#### Visualization
- `createChart()`: Main chart rendering with D3.js
- `updateStatsTable()`: Populates statistics table
- `highlightElements()`: Synchronized hover effects
- `selectBlock()`: Handle block selection and code display
- `showCode()`: Display code for selected block
- `clearCode()`: Reset code panel

#### File Handling
- Drag-and-drop support
- File validation (JSON only)
- Error handling for malformed data
- URL loading with GitHub support

### Performance Optimizations
- Groups small blocks (<0.1% threshold) to reduce visual clutter
- Uses log scale for color mapping to handle wide instruction count ranges
- Efficient D3.js updates with proper enter/exit patterns
- Maintains selection state across metric changes

## Styling

### Color Scheme
- Primary: Bootstrap primary blue (#0d6efd)
- Highlight: Yellow (#ffc10755 for hover, #ffc107 for selection)
- Background: Light gray (#f8f9fa)
- Chart colors: Red-Yellow-Green gradient (log scale)
- Grid lines: Light gray (#e0e0e0)

### Responsive Design
- Bootstrap grid system for layout
- Scrollable tables for long lists (max-height: 400px)
- Tooltip positioning follows cursor
- Responsive column layout (lg-8 for chart, lg-4 for stats)

## Usage Instructions

1. **Load Data**: Upload JSON file or paste URL
2. **Select Metric**: Choose effectiveness measurement type
3. **Explore**: 
   - Hover over bars/rows to see details in tooltip
   - Click to select and view code
   - Compare blocks by effectiveness and impact
   - Observe mean effectiveness line for overall performance
4. **Reset**: Click title to return to upload screen

## Browser Compatibility
Modern browsers with ES6+ support required for:
- Arrow functions
- Template literals
- Array methods (map, filter, reduce)
- D3.js v7 requirements

## Development Notes

### Adding New Metrics
To add a new effectiveness metric:
1. Add option to effectiveness type select dropdown
2. Update `calculateEffectiveness()` function with new case
3. Ensure data structure includes required fields

### Customizing Visualizations
- Chart dimensions: Modify margin, width, and height variables
- Color scales: Adjust interpolator or domain for instruction color mapping
- Grouping threshold: Change 0.1% threshold for "Other" grouping
- Grid appearance: Modify grid line styles and opacity

### State Management
- `currentData`: Stores loaded JSON data
- `selectedBlock`: Tracks currently selected block
- Selection persists across metric changes when block still exists

### Error Handling
- JSON parsing errors caught and displayed to user
- File type validation (only .json accepted)
- Graceful handling of missing data fields

## Relationship to Original Python Script

This web application is a port of `plot_effectiveness.py` from the powdr project, with the following enhancements:
- **Interactive visualization** instead of static matplotlib plots
- **Real-time metric switching** without regenerating plots
- **Synchronized hover/selection** across chart, table, and code view
- **Code display** for selected basic blocks
- **URL loading** support for remote data files
- **No installation required** - runs entirely in the browser

The core logic (effectiveness calculation, data processing, grouping threshold) remains identical to ensure consistency with the original analysis tool.

## zkVM-Specific Concepts

### Basic Blocks
Contiguous sequences of RISC-V instructions with single entry/exit points. Each block becomes a candidate for precompile generation.

### Trace Cells
The product of `width_before * execution_frequency`, representing the total computational impact of a basic block in the program trace. High trace cell counts indicate hot paths that benefit most from optimization.

### Effectiveness Ratio
Values > 1.0 indicate improvement (reduction in cost/resources). For example, effectiveness of 2.0 means the precompile reduces the metric by 50%.

### Precompile Impact
The tool helps identify which basic blocks provide the best return on investment for precompile generation, focusing optimization efforts on the most impactful code paths.

## Potential Improvements
- Export functionality for charts/data (SVG, PNG, CSV)
- Multiple file comparison side-by-side
- Time-series analysis for effectiveness trends
- Additional chart types (scatter plot, heatmap)
- Filtering/search for specific PC ranges
- Save/load visualization state
- Keyboard shortcuts for navigation
- Detailed statistics panel with percentiles
- Performance profiling for large datasets
- Mobile-responsive chart sizing
- Integration with powdr toolchain for direct data loading
- Comparison between different precompile strategies
- Cost-benefit analysis (precompile generation cost vs. runtime savings)